using System;
using System.Collections.Generic;
using System.Diagnostics;
using LinearDiff3DGame.AdvMath.Common;
using LinearDiff3DGame.Common;
using LinearDiff3DGame.Geometry3D.Common;
using LinearDiff3DGame.Geometry3D.PolyhedronGraph;

namespace LinearDiff3DGame.MaxStableBridge.Crossing
{
    internal class CrossingObjectsSearch
    {
        public CrossingObjectsSearch(ApproxComp approxComparer)
        {
            this.approxComparer = approxComparer;
        }

        public IList<CrossingObject> GetCrossingObjects(Polyhedron3DGraph graph, Vector3D direction)
        {
            List<CrossingObject> crossingObjects = new List<CrossingObject>();
            CrossingObject first = GetFirstCrossingObject(graph.NodeList[0], direction);
            crossingObjects.Add(first);
            CrossingObject next = null;
            while ((next = GetNextCrossingObject(next ?? first, direction)) != first)
                crossingObjects.Add(next);
            return crossingObjects;
        }

        // TODO : рефакторинг
        public CrossingObject GetFirstCrossingObject(Polyhedron3DGraphNode startNode, Vector3D direction)
        {
            CrossingObject firstCrossingObject = null;
            Polyhedron3DGraphNode currentNode = startNode;
            Double currentScalarProduct = Vector3D.ScalarProduct(currentNode.NodeNormal, direction);
            if (approxComparer.EQ(currentScalarProduct, 0))
                firstCrossingObject = new CrossingObject(CrossingObjectType.GraphNode, currentNode, currentNode);
            while (firstCrossingObject == null)
            {
                Double bestScalarProduct = Double.NaN;
                Polyhedron3DGraphNode bestNode = null;
                foreach (Polyhedron3DGraphNode currentConn in currentNode.ConnectionList)
                {
                    Double scalarProduct = Vector3D.ScalarProduct(currentConn.NodeNormal, direction);
                    // если скал€рное произведение = 0, то полученный узел становитс€ искомым объектом
                    if (approxComparer.EQ(scalarProduct, 0))
                    {
                        firstCrossingObject = new CrossingObject(CrossingObjectType.GraphNode,
                                                                 currentConn,
                                                                 currentConn);
                        break;
                    }
                    // если знаки скал€рных произведений currentScalarProduct и scalarProduct различаютс€
                    // то узлы currentNode и currentConn образуют искомый объект
                    if (Math.Sign(currentScalarProduct) != Math.Sign(scalarProduct))
                    {
                        Polyhedron3DGraphNode plusNode = (currentScalarProduct > 0 ? currentNode : currentConn);
                        Polyhedron3DGraphNode minusNode = (currentScalarProduct < 0 ? currentNode : currentConn);
                        firstCrossingObject = new CrossingObject(CrossingObjectType.GraphConnection, plusNode, minusNode);
                        break;
                    }
                    // ищем узел, дл€ которого величина скал€рного произведени€ ближе всех к 0
                    // что означает, что сам узел ближе всех к плоскости, перпендикул€рной вектору directingVectorXi
                    if (Double.IsNaN(bestScalarProduct) || (Math.Abs(scalarProduct) < Math.Abs(bestScalarProduct)))
                    {
                        bestScalarProduct = scalarProduct;
                        bestNode = currentConn;
                    }
                }
                currentNode = bestNode;
                currentScalarProduct = bestScalarProduct;
            }
            return firstCrossingObject;
        }

        public CrossingObject GetNextCrossingObject(CrossingObject currentCrossingObject, Vector3D direction)
        {
            if (currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphNode)
                return GetNextCrossingObject4Node(currentCrossingObject, direction);
            return GetNextCrossingObject4Connection(currentCrossingObject, direction);
        }

        private CrossingObject GetNextCrossingObject4Node(CrossingObject currentCrossingObject, Vector3D direction)
        {
            Debug.Assert(currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphNode);
            Polyhedron3DGraphNode crossingNode = currentCrossingObject.PositiveNode;
            foreach (Polyhedron3DGraphNode currentConnNode in crossingNode.ConnectionList)
            {
                Polyhedron3DGraphNode nextConnNode = crossingNode.ConnectionList.GetNextItem(currentConnNode);
                Double currentScalarProdut = Vector3D.ScalarProduct(currentConnNode.NodeNormal, direction);
                Double nextScalarProdut = Vector3D.ScalarProduct(nextConnNode.NodeNormal, direction);
                // правильным объектом пересечени€ всегда будет такой, когда дл€ текущией св€зи следуща€ €вл€етс€ положительным узлом
                // если непон€тно, то нарисуй !!!
                if (approxComparer.EQ(currentScalarProdut, 0) && approxComparer.GT(nextScalarProdut, 0))
                    return new CrossingObject(CrossingObjectType.GraphNode, currentConnNode, currentConnNode);
                if (approxComparer.LT(currentScalarProdut, 0) && approxComparer.GT(nextScalarProdut, 0))
                    return new CrossingObject(CrossingObjectType.GraphConnection, nextConnNode, currentConnNode);
            }
            throw new Exception("Abnormal algorithm result");
        }

        private CrossingObject GetNextCrossingObject4Connection(CrossingObject currentCrossingObject, Vector3D direction)
        {
            Debug.Assert(currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection);
            Polyhedron3DGraphNode positiveNode = currentCrossingObject.PositiveNode;
            Polyhedron3DGraphNode negativeNode = currentCrossingObject.NegativeNode;
            Polyhedron3DGraphNode positiveNextNode = positiveNode.ConnectionList.GetNextItem(negativeNode);
            Polyhedron3DGraphNode negativePrevNode = negativeNode.ConnectionList.GetPrevItem(positiveNode);
            // инвариант целостности графа
            Debug.Assert(positiveNextNode == negativePrevNode);
            Double scalarProductValue = Vector3D.ScalarProduct(positiveNextNode.NodeNormal, direction);
            if (approxComparer.EQ(scalarProductValue, 0))
                return new CrossingObject(CrossingObjectType.GraphNode, positiveNextNode, positiveNextNode);
            if (approxComparer.GT(scalarProductValue, 0))
                return new CrossingObject(CrossingObjectType.GraphConnection, positiveNextNode, negativeNode);
            return new CrossingObject(CrossingObjectType.GraphConnection, positiveNode, negativePrevNode);
        }

        ///// <summary>
        ///// метод GetFirstCrossingObject возвращает первый объект пересечени€ графа с G(...Xi...)
        ///// </summary>
        ///// <param name="startNode">узел графа, с которого начинаетс€ поиск</param>
        ///// <param name="directingVectorXi">направл€ющий вектор отрезка Xi</param>
        ///// <returns>первый объект пересечени€ графа с G(...Xi...)</returns>
        //public CrossingObject GetFirstCrossingObject(Polyhedron3DGraphNode startNode, Vector3D directingVectorXi)
        //{
        //    if (startNode == null) throw new ArgumentNullException("startNode");

        //    CrossingObject firstCrossingObject = null;

        //    Polyhedron3DGraphNode currentNode = startNode;
        //    Double currentScalarProduct = Vector3D.ScalarProduct(currentNode.NodeNormal, directingVectorXi);
        //    if (approxComparer.EQ(currentScalarProduct, 0))
        //        firstCrossingObject = new CrossingObject(CrossingObjectType.GraphNode, currentNode, currentNode);
        //    while (firstCrossingObject == null)
        //    {
        //        Double bestScalarProduct = Double.NaN;
        //        Polyhedron3DGraphNode bestNode = null;
        //        foreach (Polyhedron3DGraphNode currentConn in currentNode.ConnectionList)
        //        {
        //            Double scalarProduct = Vector3D.ScalarProduct(currentConn.NodeNormal, directingVectorXi);
        //            // если скал€рное произведение = 0, то полученный узел становитс€ искомым объектом
        //            if (approxComparer.EQ(scalarProduct, 0))
        //            {
        //                firstCrossingObject = new CrossingObject(CrossingObjectType.GraphNode,
        //                                                         currentConn,
        //                                                         currentConn);
        //                break;
        //            }
        //            // если знаки скал€рных произведений currentScalarProduct и scalarProduct различаютс€
        //            // то узлы currentNode и currentConn образуют искомый объект
        //            if (Math.Sign(currentScalarProduct) != Math.Sign(scalarProduct))
        //            {
        //                Polyhedron3DGraphNode plusNode = (currentScalarProduct > 0 ? currentNode : currentConn);
        //                Polyhedron3DGraphNode minusNode = (currentScalarProduct < 0 ? currentNode : currentConn);
        //                firstCrossingObject = new CrossingObject(CrossingObjectType.GraphConnection, plusNode, minusNode);
        //                break;
        //            }
        //            // ищем узел, дл€ которого величина скал€рного произведени€ ближе всех к 0
        //            // что означает, что сам узел ближе всех к плоскости, перпендикул€рной вектору directingVectorXi
        //            if (Double.IsNaN(bestScalarProduct) || (Math.Abs(scalarProduct) < Math.Abs(bestScalarProduct)))
        //            {
        //                bestScalarProduct = scalarProduct;
        //                bestNode = currentConn;
        //            }
        //        }
        //        currentNode = bestNode;
        //        currentScalarProduct = bestScalarProduct;
        //    }
        //    return firstCrossingObject;
        //}

        private readonly ApproxComp approxComparer;
    }

//    /// <summary>
//    /// класс дл€ нахождени€ пересечений графа с G(...Xi...), где Xi - некий отрезок, G(...Xi...) - большой круг, перпендикул€рный Xi и проход€щий через точку 0
//    /// </summary>
//    internal class CrossingObjectFinder
//    {
//        /// <summary>
//        /// конструктор класса CrossingObjectFinder
//        /// </summary>
//        /// <param name="approxComparer">сравниватель, дл€ приближенного сравнени€ действительных чисел</param>
//        public CrossingObjectFinder(ApproxComp approxComparer)
//        {
//            m_ApproxComparer = approxComparer;
//        }

//        /// <summary>
//        /// метод GetFirstCrossingObject возвращает первый объект пересечени€ графа с G(...Xi...)
//        /// </summary>
//        /// <param name="startNode">узел графа, с которого начинаетс€ поиск</param>
//        /// <param name="directingVectorXi">направл€ющий вектор отрезка Xi</param>
//        /// <returns>первый объект пересечени€ графа с G(...Xi...)</returns>
//        public CrossingObject GetFirstCrossingObject(Polyhedron3DGraphNode startNode, Vector3D directingVectorXi)
//        {
//            CrossingObject firstCrossingObject = null;

//            // текущий узел
//            Polyhedron3DGraphNode currentNode = startNode;
//            // вычисл€ем скал€рное произведение вектора, св€занного с текущим узлом, и направл€ющего вектора отрезка Xi
//            Double currentScalarProduct = Vector3D.ScalarProduct(currentNode.NodeNormal, directingVectorXi);
//            // если скал€рное произведение = 0, то текущий узел становитс€ искомым объектом
//            if (m_ApproxComparer.EQ(currentScalarProduct, 0))
//            {
//                firstCrossingObject = new CrossingObject(CrossingObjectType.GraphNode, currentNode, currentNode);
//            }

//            // цикл пока не найден искомый первый объект пересечени€
//            while (ReferenceEquals(firstCrossingObject, null))
//            {
//                Double bestScalarProduct = Double.NaN;
//                Polyhedron3DGraphNode bestNode = null;

//                // цикл по всем св€з€м текущего узла
//                for (Int32 connIndex = 0; connIndex < currentNode.ConnectionList.Count; ++connIndex)
//                {
//                    // текуща€ св€зь текущего узла
//                    Polyhedron3DGraphNode currentConnNode = currentNode.ConnectionList[connIndex];
//                    // считаем скал€рное произведение вектора, св€занного с полученным выше узлом, и направл€ющего вектора отрезка Xi
//                    Double scalarProduct = Vector3D.ScalarProduct(currentConnNode.NodeNormal, directingVectorXi);

//                    // если скал€рное произведение = 0, то полученный узел становитс€ искомым объектом
//                    if (m_ApproxComparer.EQ(scalarProduct, 0))
//                    {
//                        firstCrossingObject = new CrossingObject(CrossingObjectType.GraphNode,
//                                                                 currentConnNode,
//                                                                 currentConnNode);
//                        break;
//                    }

//                    // если скал€рное произведение того же знака, что и дл€ вектора, св€занного с текущим узлом, то
//                    // если по абсолютному значению величина скал€рного произведени€ меньше запомненного, то запоминаем величину и полученный узел
//                    if (Math.Sign(currentScalarProduct) == Math.Sign(scalarProduct))
//                    {
//                        if (Double.IsNaN(bestScalarProduct) ||
//                            (Math.Abs(scalarProduct) < Math.Abs(bestScalarProduct)))
//                        {
//                            bestScalarProduct = scalarProduct;
//                            bestNode = currentConnNode;
//                        }
//                    }
//                        // если знак скал€рного произведени€ дл€ полученного (выше) вектора, отличаетс€ от знака скал€рного произведени€ дл€ вектора, св€занного с текущим узлом, то
//                        // св€зь, соедин€юща€ текущий и полученный (выше) узлы становитс€ искомым объектом
//                    else
//                    {
//                        Polyhedron3DGraphNode plusNode = (currentScalarProduct > 0 ? currentNode : currentConnNode);
//                        Polyhedron3DGraphNode minusNode = (currentScalarProduct < 0 ? currentNode : currentConnNode);

//                        firstCrossingObject = new CrossingObject(CrossingObjectType.GraphConnection, plusNode, minusNode);
//                        break;
//                    }
//                }

//                // текущим узлом становитс€ запомненный узел
//                currentNode = bestNode;
//                currentScalarProduct = bestScalarProduct;
//            }

//            return firstCrossingObject;
//        }

//        /// <summary>
//        /// метод GetNextCrossingObject возвращает следующий по направлению движени€ объект пересечени€
//        /// при этом текущий объект пересечени€ currentCrossingObject может быть "испорчен" из-за наличи€ 
//        /// внутри него узла (если текущий объект пересечени€ - св€зь) currentCrossingNode на пересечении объекта и G(...Xi...)
//        /// </summary>
//        /// <param name="currentCrossingObject">текущий объект пересечени€ графа с G(...Xi...)</param>
//        /// <param name="currentCrossingNode">узел на текущем пересечении графа с G(...Xi...)</param>
//        /// <param name="directingVectorXi">направл€ющий вектор отрезка Xi</param>
//        /// <returns>следующий по направлению движени€ объект пересечени€</returns>
//        public CrossingObject GetNextCrossingObject(CrossingObject currentCrossingObject,
//                                                    Polyhedron3DGraphNode currentCrossingNode,
//                                                    Vector3D directingVectorXi)
//        {
//            CrossingObject nextCrossingObject;

//            // если текущий объект Ц узел
//            if (currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphNode)
//            {
//                nextCrossingObject = GetNextCrossingObject4GraphNode(currentCrossingObject, directingVectorXi);
//            }
//                // если текущий объект Ц св€зь
//            else
//            {
//                nextCrossingObject = GetNextCrossingObject4GraphConn(currentCrossingObject, currentCrossingNode,
//                                                                     directingVectorXi);
//            }

//            return nextCrossingObject;
//        }

//        /// <summary>
//        /// метод GetNextCrossingObject возвращает следующий по направлению движени€ объект пересечени€
//        /// </summary>
//        /// <param name="currentCrossingObject">текущий объект пересечени€ графа с G(...Xi...)</param>
//        /// <param name="directingVectorXi">направл€ющий вектор отрезка Xi</param>
//        /// <returns>следующий по направлению движени€ объект пересечени€</returns>
//        public CrossingObject GetNextCrossingObject(CrossingObject currentCrossingObject, Vector3D directingVectorXi)
//        {
//            CrossingObject nextCrossingObject;

//            // если текущий объект Ц узел
//            if (currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphNode)
//            {
//                nextCrossingObject = GetNextCrossingObject4GraphNode(currentCrossingObject, directingVectorXi);
//            }
//                // если текущий объект Ц св€зь
//            else
//            {
//                nextCrossingObject = GetNextCrossingObject4GraphConn(currentCrossingObject, directingVectorXi);
//            }

//            return nextCrossingObject;
//        }

//        /// <summary>
//        /// метод GetNextCrossingObject4GraphNode возвращает следующий по направлению движени€ объект пересечени€, если текущий - узел
//        /// </summary>
//        /// <param name="currentCrossingObject">текущий объект пересечени€ графа с G(...Xi...)</param>
//        /// <param name="directingVectorXi">направл€ющий вектор отрезка Xi</param>
//        /// <returns>следующий по направлению движени€ объект пересечени€</returns>
//        private CrossingObject GetNextCrossingObject4GraphNode(CrossingObject currentCrossingObject,
//                                                               Vector3D directingVectorXi)
//        {
//            CrossingObject nextCrossingObject = null;

//            Polyhedron3DGraphNode currentNode = currentCrossingObject.PositiveNode;
//            // цикл по всем св€з€м текущего узла
//            for (Int32 connIndex = 0; connIndex < currentNode.ConnectionList.Count; ++connIndex)
//            {
//                // получаем узел (номер 1), св€занный с текущим узлом текущей св€зью
//                Polyhedron3DGraphNode node1 = currentNode.ConnectionList[connIndex];
//                // получаем узел (номер 2), св€занный с текущим узлом предыдущей св€зью
//                Polyhedron3DGraphNode node2 = currentNode.ConnectionList.GetPrevItem(connIndex);

//                // вычисл€ем скал€рное произведение вектора 1 и направл€ющего вектора Xi
//                Double scalarProduct1 = Vector3D.ScalarProduct(node1.NodeNormal, directingVectorXi);
//                // вычисл€ем скал€рное произведение вектора 2 и направл€ющего вектора Xi
//                Double scalarProduct2 = Vector3D.ScalarProduct(node2.NodeNormal, directingVectorXi);

//                // если скал€рное произведение узла 1 и направл€ющего вектора Xi == 0
//                if (m_ApproxComparer.EQ(scalarProduct1, 0))
//                {
//                    // если направление движени€ выбрано правильно, то узел номер 1 становитс€ следующим по движению объектом
//                    nextCrossingObject = new CrossingObject(CrossingObjectType.GraphNode, node1, node1);
//                    if (CheckMoveDirection(nextCrossingObject, currentCrossingObject, directingVectorXi))
//                    {
//                        break;
//                    }
//                    nextCrossingObject = null;
//                }

//                // если скал€рное произведение узла 2 и направл€ющего вектора Xi == 0
//                if (m_ApproxComparer.EQ(scalarProduct2, 0))
//                {
//                    // если направление движени€ выбрано правильно, то узел номер 2 становитс€ следующим по движению объектом
//                    nextCrossingObject = new CrossingObject(CrossingObjectType.GraphNode, node2, node2);
//                    if (CheckMoveDirection(nextCrossingObject, currentCrossingObject, directingVectorXi))
//                    {
//                        break;
//                    }
//                    nextCrossingObject = null;
//                }

//                // если скал€рные произведени€ узлов 1 и 2 и направл€ющего вектора Xi имеют разный знак
//                if (Math.Sign(scalarProduct1) != Math.Sign(scalarProduct2))
//                {
//                    // если направление движени€ выбрано правильно, то св€зь, соедин€юща€ узлы 1 и 2, становитс€ следующим по движению объектом
//                    Polyhedron3DGraphNode plusNode = (scalarProduct1 > 0 ? node1 : node2);
//                    Polyhedron3DGraphNode minusNode = (scalarProduct1 < 0 ? node1 : node2);
//                    nextCrossingObject = new CrossingObject(CrossingObjectType.GraphConnection, plusNode, minusNode);
//                    if (CheckMoveDirection(nextCrossingObject, currentCrossingObject, directingVectorXi))
//                    {
//                        break;
//                    }
//                    nextCrossingObject = null;
//                }
//            }
//            // цикл по всем св€з€м текущего узла

//            return nextCrossingObject;
//        }

//        /// <summary>
//        /// метод GetNextCrossingObject4GraphConn возвращает следующий по направлению движени€ объект пересечени€, если текущий - св€зь
//        /// при этом текущий объект пересечени€ currentCrossingObject может быть "испорчен" из-за наличи€ 
//        /// внутри него узла currentCrossingNode на пересечении объекта и G(...Xi...)
//        /// </summary>
//        /// <param name="currentCrossingObject">текущий объект пересечени€ графа с G(...Xi...)</param>
//        /// <param name="currentCrossingNode">узел на текущем пересечении графа с G(...Xi...)</param>
//        /// <param name="directingVectorXi">направл€ющий вектор отрезка Xi</param>
//        /// <returns>следующий по направлению движени€ объект пересечени€</returns>
//        private CrossingObject GetNextCrossingObject4GraphConn(CrossingObject currentCrossingObject,
//                                                               Polyhedron3DGraphNode currentCrossingNode,
//                                                               Vector3D directingVectorXi)
//        {
//            CrossingObject nextCrossingObject = null;

//            // положительный узел текущей св€зи
//            Polyhedron3DGraphNode plusNode = currentCrossingObject.PositiveNode;
//            // отрицательный узел текущей св€зи
//            Polyhedron3DGraphNode minusNode = currentCrossingObject.NegativeNode;

//            // дл€ положительного узла (currentCrossingObject.PositiveNode) берем следующую св€зь (относительно текущей)
//            Polyhedron3DGraphNode nextNode1 = plusNode.ConnectionList.GetNextItem(currentCrossingNode);
//            // дл€ отрицательного узла (currentCrossingObject.NegativeNode) берем предыдущую св€зь (относительно текущей)
//            Polyhedron3DGraphNode nextNode2 = minusNode.ConnectionList.GetPrevItem(currentCrossingNode);

//            Double scalarProduct1 = Vector3D.ScalarProduct(nextNode1.NodeNormal, directingVectorXi);
//            Double scalarProduct2 = Vector3D.ScalarProduct(nextNode2.NodeNormal, directingVectorXi);

//            //// если полученный узел (номер 1) нулевой
//            //if (m_ApproxComparer.EQ(scalarProduct1, 0))
//            //{
//            //    // если полученный узел номер 2 нулевой
//            //    if (m_ApproxComparer.EQ(scalarProduct2, 0))
//            //    {
//            //        // полученный узел становитс€ следующим по движению объектом
//            //        nextCrossingObject = new CrossingObject(CrossingObjectType.GraphNode, nextNode1, nextNode1);
//            //        // exit
//            //    }
//            //        // если полученный узел номер 2 ненулевой
//            //    else
//            //    {
//            //        // "св€зь" (это св€зь, с которой мы начинали движение; реально ее уже нет) соедин€юща€ положительный узел и узел номер 2 становитс€ следующим по движению объектом
//            //        // —в€зи с которой мы начинали движение нет из-за того, что на первом шаге между узлами св€зи был построен узел на пересечении этой св€зи и G(...Pi...)
//            //        nextCrossingObject = new CrossingObject(CrossingObjectType.GraphConnection, plusNode, nextNode2);
//            //        // exit
//            //    }
//            //}
//            if (m_ApproxComparer.EQ(scalarProduct1, 0) || m_ApproxComparer.EQ(scalarProduct2, 0))
//            {
//                if (m_ApproxComparer.EQ(scalarProduct1, 0) && m_ApproxComparer.EQ(scalarProduct2, 0))
//                {
//                    // полученный узел становитс€ следующим по движению объектом
//                    nextCrossingObject = new CrossingObject(CrossingObjectType.GraphNode, nextNode1, nextNode1);
//                    // exit
//                }
//                else if (m_ApproxComparer.EQ(scalarProduct1, 0) && m_ApproxComparer.NE(scalarProduct2, 0))
//                {
//                    // "св€зь" (это св€зь, с которой мы начинали движение; реально ее уже нет) соедин€юща€ положительный узел и узел номер 2 становитс€ следующим по движению объектом
//                    // —в€зи с которой мы начинали движение нет из-за того, что на первом шаге между узлами св€зи был построен узел на пересечении этой св€зи и G(...Pi...)
//                    nextCrossingObject = new CrossingObject(CrossingObjectType.GraphConnection, plusNode, nextNode2);
//                    // exit
//                }
//                else if (m_ApproxComparer.NE(scalarProduct1, 0) && m_ApproxComparer.EQ(scalarProduct2, 0))
//                {
//                    // "св€зь" (это св€зь, с которой мы начинали движение; реально ее уже нет) соедин€юща€ положительный узел и узел номер 2 становитс€ следующим по движению объектом
//                    // —в€зи с которой мы начинали движение нет из-за того, что на первом шаге между узлами св€зи был построен узел на пересечении этой св€зи и G(...Pi...)
//                    nextCrossingObject = new CrossingObject(CrossingObjectType.GraphConnection, nextNode1, minusNode);
//                    // exit
//                }
//            }
//                // если полученный узел (номер 1) положительный
//            else if (m_ApproxComparer.GT(scalarProduct1, 0))
//            {
//                // св€зь, соедин€юща€ новый положительный узел и старый отрицательный узел, становитс€ следующим по движению объектом
//                nextCrossingObject = new CrossingObject(CrossingObjectType.GraphConnection, nextNode1, minusNode);
//                // exit
//            }
//                // если полученный узел (номер 1) отрицательный
//            else if (m_ApproxComparer.LT(scalarProduct1, 0))
//            {
//                // св€зь, соедин€юща€ новый отрицательный узел и старый положительный узел, становитс€ следующим по движению объектом
//                nextCrossingObject = new CrossingObject(CrossingObjectType.GraphConnection, plusNode, nextNode2);
//                // exit
//            }

//            return nextCrossingObject;
//        }

//        /// <summary>
//        /// метод GetNextCrossingObject4GraphConn возвращает следующий по направлению движени€ объект пересечени€, если текущий - св€зь
//        /// </summary>
//        /// <param name="currentCrossingObject">текущий объект пересечени€ графа с G(...Xi...)</param>
//        /// <param name="directingVectorXi">направл€ющий вектор отрезка Xi</param>
//        /// <returns>следующий по направлению движени€ объект пересечени€</returns>
//        private CrossingObject GetNextCrossingObject4GraphConn(CrossingObject currentCrossingObject,
//                                                               Vector3D directingVectorXi)
//        {
//            CrossingObject nextCrossingObject = null;

//            // положительный узел текущей св€зи
//            Polyhedron3DGraphNode plusNode = currentCrossingObject.PositiveNode;
//            // отрицательный узел текущей св€зи
//            Polyhedron3DGraphNode minusNode = currentCrossingObject.NegativeNode;

//            // дл€ положительного узла (CurrentCrossingObject.PositiveNode) берем следующую св€зь (относительно текущей)
//            Polyhedron3DGraphNode nextNode1 = plusNode.ConnectionList.GetNextItem(minusNode);
//            // дл€ отрицательного узла (CurrentCrossingObject.NegativeNode) берем предыдущую св€зь (относительно текущей)
//            Polyhedron3DGraphNode nextNode2 = minusNode.ConnectionList.GetPrevItem(plusNode);

//            Double scalarProduct1 = Vector3D.ScalarProduct(nextNode1.NodeNormal, directingVectorXi);
//            Double scalarProduct2 = Vector3D.ScalarProduct(nextNode2.NodeNormal, directingVectorXi);

////            // если полученный узел (номер 1) нулевой
////            if (m_ApproxComparer.EQ(scalarProduct1, 0))
////            {
////                // если полученный узел номер 2 не нулевой
////                if (m_ApproxComparer.NE(scalarProduct2, 0))
////                {
////#warning может более специализированное исключение
////                    throw new Exception("GetNextCrossingObject4GraphConn2 method incorrect work");
////                }

////                // полученный узел становитс€ следующим по движению объектом
////                nextCrossingObject = new CrossingObject(CrossingObjectType.GraphNode, nextNode1, nextNode1);
////                // exit
////            }
//            if (m_ApproxComparer.EQ(scalarProduct1, 0) || m_ApproxComparer.EQ(scalarProduct2, 0))
//            {
//                if (m_ApproxComparer.EQ(scalarProduct1, 0) && m_ApproxComparer.EQ(scalarProduct2, 0))
//                {
//                    // полученный узел становитс€ следующим по движению объектом
//                    nextCrossingObject = new CrossingObject(CrossingObjectType.GraphNode, nextNode1, nextNode1);
//                    // exit
//                }
//                else
//                {
//#warning может более специализированное исключение
//                    throw new Exception("GetNextCrossingObject4GraphConn2 method incorrect work");
//                }
//            }
//                // если полученный узел (номер 1) положительный
//            else if (m_ApproxComparer.GT(scalarProduct1, 0))
//            {
//                // св€зь, соедин€юща€ новый положительный узел и старый отрицательный узел, становитс€ следующим по движению объектом
//                nextCrossingObject = new CrossingObject(CrossingObjectType.GraphConnection, nextNode1, minusNode);
//                // exit
//            }
//                // если полученный узел (номер 1) отрицательный
//            else if (m_ApproxComparer.LT(scalarProduct1, 0))
//            {
//                // св€зь, соедин€юща€ новый отрицательный узел и старый положительный узел, становитс€ следующим по движению объектом
//                nextCrossingObject = new CrossingObject(CrossingObjectType.GraphConnection, plusNode, nextNode2);
//                // exit
//            }

//            return nextCrossingObject;
//        }

//        /// <summary>
//        /// метод CalcCrossingNodeNormal вычисл€ет нормаль узла на текущем пересечении графа с G(...Xi...)
//        /// Xi - некий отрезок, G(...Xi...) - большой круг, перпендикул€рный Xi и проход€щий через точку 0
//        /// </summary>
//        /// <param name="currentCrossingObject">текущий объект пересечени€ графа с G(...Xi...)</param>
//        /// <param name="directingVectorXi">направл€ющий вектор отрезка Xi</param>
//        /// <returns>нормаль узла на текущем пересечении графа с G(...Xi...)</returns>
//        private Vector3D CalcCrossingNodeNormal(CrossingObject currentCrossingObject, Vector3D directingVectorXi)
//        {
//            Vector3D crossingNodeNormal;

//            if (currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection)
//            {
//                Vector3D plusVector = currentCrossingObject.PositiveNode.NodeNormal;
//                Vector3D minusVector = currentCrossingObject.NegativeNode.NodeNormal;
//                // —троим вектор, перпендикул€рный векторам, св€занным текущей св€зью,
//                // как векторное произведение положительного узла св€зи на отрицательный
//                Vector3D npm = Vector3D.VectorProduct(plusVector, minusVector);
//                // ¬ычисл€ем векторное произведение построенного вектора и направл€ющего вектора Xi
//                crossingNodeNormal = Vector3D.VectorProduct(npm, directingVectorXi);
//                crossingNodeNormal.Normalize();
//            }
//            else
//            {
//                crossingNodeNormal = currentCrossingObject.PositiveNode.NodeNormal;
//            }

//            return crossingNodeNormal;
//        }

//        /// <summary>
//        /// метод CheckMoveDirection возвращает true, если направление движени€ по G(...Xi...) правильное, иначе возвращаетс€ false
//        /// правильным считаетс€ направление движени€ против часовой стрелки, если смотреть с конца направл€ющего вектора Xi
//        /// </summary>
//        /// <param name="checkCrossingObject">провер€емый объект пересечени€ графа с G(...Xi...)</param>
//        /// <param name="currentCrossingObject">текущий объект пересечени€ графа с G(...Xi...)</param>
//        /// <param name="directingVectorXi">направл€ющий вектор отрезка Xi</param>
//        /// <returns>true, если при построении объектов пересечени€ мы двигаемс€ правильное; иначе - false</returns>
//        private Boolean CheckMoveDirection(CrossingObject checkCrossingObject, CrossingObject currentCrossingObject,
//                                           Vector3D directingVectorXi)
//        {
//            // направл€ющий вектор Xi становитс€ ортом оси OZ
//            Vector3D directingVectorOZ = directingVectorXi;

//            // строим пересечение текущего объекта и G(...Xi...); вектор, полученный при построении пересечени€, становитс€ ортом оси OX
//            Vector3D directingVectorOX = CalcCrossingNodeNormal(currentCrossingObject, directingVectorXi);

//            // строим орт оси OY правой —  XYZ (как векторное произведение орта оси OZ на орт оси OX)
//            Vector3D directingVectorOY = Vector3D.VectorProduct(directingVectorOZ, directingVectorOX);

//            // строим пересечение провер€емого объекта и G(...Xi...); вычисл€ем скал€рное произведение вектора, полученного при построении пересечени€, и орта оси OY
//            Vector3D checkVector = CalcCrossingNodeNormal(checkCrossingObject, directingVectorXi);
//            Double scalarProduct = Vector3D.ScalarProduct(checkVector, directingVectorOY);

//            // если ScalarProductValue = 0 - это ошибка работы алгоритма
//            if (m_ApproxComparer.EQ(scalarProduct, 0))
//            {
//#warning может более специализированное исключение
//                throw new Exception("CheckMoveDirection method incorrect work");
//            }

//            // если вычисленное скал€рное произведение > 0, то направление движени€ правильное, иначе направление движени€ неправильное
//            return (scalarProduct > 0 ? true : false);
//        }

//        /// <summary>
//        /// сравниватель, дл€ приближенного сравнени€ действительных чисел
//        /// </summary>
//        private readonly ApproxComp m_ApproxComparer;
//    }
}