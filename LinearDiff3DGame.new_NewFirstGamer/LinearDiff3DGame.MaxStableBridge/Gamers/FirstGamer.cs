using System;
using System.Collections.Generic;
using System.Diagnostics;
using LinearDiff3DGame.AdvMath;
using LinearDiff3DGame.AdvMath.Common;
using LinearDiff3DGame.Common;
using LinearDiff3DGame.Geometry3D.Common;
using LinearDiff3DGame.Geometry3D.PolyhedronGraph;
using LinearDiff3DGame.MaxStableBridge.Crossing;

namespace LinearDiff3DGame.MaxStableBridge.Gamers
{
    /// <summary>
    /// класс представл€ющий и инкапсулирующий действи€ первого игрока
    /// в результате действий первого игрока мы получаем граф G(...Fi...)
    /// </summary>
    public /*internal*/ class FirstGamer
    {
        public FirstGamer(FirstGamerInitData initData)
        {
            approxComparer = initData.ApproxComp;
            matrixB = initData.Matrix;
            mpMax = initData.MaxSection;
            mpMin = initData.MinSection;
            deltaT = initData.DeltaT;
            angleNearnessComparer = new ApproxComp(initData.SeparateNodeValue);
        }

        [Obsolete]
        public FirstGamer(ApproxComp approxComparer, Matrix matrixB, Double deltaT, Double mpMax, Double mpMin)
        {
            this.approxComparer = approxComparer;
            const Double epsilon = 0.02;
            angleNearnessComparer = new ApproxComp(epsilon * epsilon);
            this.matrixB = matrixB;
            this.deltaT = deltaT;
            this.mpMax = mpMax;
            this.mpMin = mpMin;
        }

        public Polyhedron3DGraph Action(Polyhedron3DGraph graph,
                                        Matrix fundCauchyMatrix,
                                        Int32 generationID,
                                        Matrix scalingMatrix)
        {
            // столбец (матрица) D дл€ данного первого игрока в данный момент времени
            Matrix matrixD = CalcMatrixD(fundCauchyMatrix, scalingMatrix);
            // вычисл€ем радиус векторы вершин отрезка Pi
            List<Vector3D> pointPiSet = new List<Vector3D>(2);
            pointPiSet.Add(new Vector3D(mpMax * matrixD[1, 1], mpMax * matrixD[2, 1], mpMax * matrixD[3, 1]));
            pointPiSet.Add(new Vector3D(mpMin * matrixD[1, 1], mpMin * matrixD[2, 1], mpMin * matrixD[3, 1]));
            // направл€ющий вектор отрезка Pi
            Vector3D directingPi = new Vector3D(matrixD[1, 1], matrixD[2, 1], matrixD[3, 1]);
            directingPi = Vector3DUtils.NormalizeVector(directingPi);
            // количество узлов в графе G(...Wi...)
            Int32 graphGWiNodeCount = graph.NodeList.Count;
            // строим граф G(...Fi...); при этом граф строитс€ не заново, а за счет модификации графа graph G(...Wi...)
            Polyhedron3DGraph graphGFi = BuildGFiGrid(graph, directingPi, generationID);
            // подсчет опорной функции дл€ старых узлов (дл€ многогранника Fi)
            for(Int32 nodeIndex = 0; nodeIndex < graphGWiNodeCount; ++nodeIndex)
            {
#warning ќ„≈Ќ№ ¬ј∆Ќќ !!!!!! ѕ–ќ¬≈–»“№ ѕ–ј¬»Ћ№Ќќ—“№ ѕќЋ”„≈Ќ»я «Ќј„≈Ќ»я ќѕќ–Ќќ… ‘”Ќ ÷»»
                Polyhedron3DGraphNode currentNode = graphGFi.NodeList[nodeIndex];
                currentNode.SupportFuncValue += deltaT * Math.Max(-(currentNode.NodeNormal * pointPiSet[0]),
                                                                  -(currentNode.NodeNormal * pointPiSet[1]));
            }
            return graphGFi;
        }

        private Matrix CalcMatrixD(Matrix fundCauchyMatrix, Matrix scalingMatrix)
        {
            Matrix matrixDBeforeScaling = fundCauchyMatrix * matrixB;
            return scalingMatrix * matrixDBeforeScaling;
        }

        // TODO : реFUCKторинг
        private Polyhedron3DGraph BuildGFiGrid(Polyhedron3DGraph graph, Vector3D directionPi, Int32 generationID)
        {
            CrossingObjectsSearch search = new CrossingObjectsSearch(approxComparer);
            IList<CrossingObject> crossingObjects = search.GetCrossingObjects(graph, directionPi);
            CrossingObject previousCrossing = CheckCrossingNearnessAndCorrect(crossingObjects[0], directionPi);
            Polyhedron3DGraphNode previousNode;
            if(previousCrossing.CrossingObjectType == CrossingObjectType.GraphConnection)
            {
                previousNode = BuildCrossingNode(previousCrossing, directionPi, graph.NodeList.Count, generationID);
                graph.NodeList.Add(previousNode);
                AddCrossingNodeBetweenConn(previousCrossing, previousNode);
            }
            else
                previousNode = previousCrossing.PositiveNode;
            CrossingObject firstCrossing = previousCrossing;
            Polyhedron3DGraphNode firstNode = previousNode;
            for(Int32 crossingObjectIndex = 1; crossingObjectIndex < crossingObjects.Count; ++crossingObjectIndex)
            {
                CrossingObject currentCrossing = CheckCrossingNearnessAndCorrect(crossingObjects[crossingObjectIndex],
                                                                                 directionPi);
                Polyhedron3DGraphNode currentNode;
                if(currentCrossing.CrossingObjectType == CrossingObjectType.GraphConnection)
                {
                    currentNode = BuildCrossingNode(currentCrossing, directionPi, graph.NodeList.Count, generationID);
                    graph.NodeList.Add(currentNode);
                    AddCrossingNodeBetweenConn(currentCrossing, currentNode);
                }
                else
                    currentNode = currentCrossing.PositiveNode;
                AddConnectionsIfNeed(previousCrossing, previousNode, currentCrossing, currentNode);
                previousCrossing = currentCrossing;
                previousNode = currentNode;
            }
            AddConnectionsIfNeed(previousCrossing, previousNode, firstCrossing, firstNode);
            return graph;
        }

        private CrossingObject CheckCrossingNearnessAndCorrect(CrossingObject crossingObject, Vector3D directionPi)
        {
            if(crossingObject.CrossingObjectType == CrossingObjectType.GraphNode)
                return crossingObject;

            Vector3D crossingNormal = CalcCrossingNormal(crossingObject, directionPi);
            Double positiveNodeCosAngle = Vector3DUtils.CosAngleBetweenVectors(crossingNormal, crossingObject.PositiveNode.NodeNormal);
            Double negativeNodeCosAngle = Vector3DUtils.CosAngleBetweenVectors(crossingNormal, crossingObject.NegativeNode.NodeNormal);
            if(positiveNodeCosAngle >= negativeNodeCosAngle && angleNearnessComparer.EQ(positiveNodeCosAngle, 1))
            {
                Polyhedron3DGraphNode crossingNode = crossingObject.PositiveNode;
                return new CrossingObject(CrossingObjectType.GraphNode, crossingNode, crossingNode);
            }
            if(negativeNodeCosAngle >= positiveNodeCosAngle && angleNearnessComparer.EQ(negativeNodeCosAngle, 1))
            {
                Polyhedron3DGraphNode crossingNode = crossingObject.NegativeNode;
                return new CrossingObject(CrossingObjectType.GraphNode, crossingNode, crossingNode);
            }
            return crossingObject;
        }

        private static Vector3D CalcCrossingNormal(CrossingObject currentCrossingObject, Vector3D directionPi)
        {
            if(currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection)
            {
                Vector3D plusVector = currentCrossingObject.PositiveNode.NodeNormal;
                Vector3D minusVector = currentCrossingObject.NegativeNode.NodeNormal;
                // —троим вектор, перпендикул€рный векторам, св€занным текущей св€зью,
                // как векторное произведение положительного узла св€зи на отрицательный
                Vector3D npm = Vector3D.VectorProduct(plusVector, minusVector);
                // ¬ычисл€ем векторное произведение построенного вектора и направл€ющего вектора Pi
                Vector3D crossingNodeNormal = Vector3D.VectorProduct(npm, directionPi);
                crossingNodeNormal = Vector3DUtils.NormalizeVector(crossingNodeNormal);
                return crossingNodeNormal;
            }
            return currentCrossingObject.PositiveNode.NodeNormal;
        }

        private Polyhedron3DGraphNode BuildCrossingNode(CrossingObject currentCrossingObject,
                                                        Vector3D directionPi,
                                                        Int32 nodeID,
                                                        Int32 generationID)
        {
            if(currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection)
            {
                Vector3D plusNodeNormal = currentCrossingObject.PositiveNode.NodeNormal;
                Vector3D minusNodeNormal = currentCrossingObject.NegativeNode.NodeNormal;
                Vector3D crossingNodeNormal = CalcCrossingNormal(currentCrossingObject, directionPi);
                Polyhedron3DGraphNode crossingNode = new Polyhedron3DGraphNode(nodeID, generationID, crossingNodeNormal);
                // TODO : подумать, что будет при delta близкой к 0 и как этого избежать
                // подсчет значени€ опорной функции дл€ построенного узла
                // (l1, l):
                Double scalarProduct1 = plusNodeNormal * crossingNodeNormal;
                // (l2, l):
                Double scalarProduct2 = minusNodeNormal * crossingNodeNormal;
                // (l1, l2):
                Double scalarProduct12 = plusNodeNormal * minusNodeNormal;
                // delta = 1 - (l1, l2)*(l1, l2)
                Double delta = 1 - scalarProduct12 * scalarProduct12;
                Double alpha = (scalarProduct1 - scalarProduct12 * scalarProduct2) / delta;
                Double beta = (scalarProduct2 - scalarProduct12 * scalarProduct1) / delta;
#warning ќ„≈Ќ№ ¬ј∆Ќќ !!!!!! ѕ–ќ¬≈–»“№ ѕ–ј¬»Ћ№Ќќ—“№ ѕќЋ”„≈Ќ»я «Ќј„≈Ќ»я ќѕќ–Ќќ… ‘”Ќ ÷»»
#warning ќ„≈Ќ№ ¬ј∆Ќќ !!!!!! считаем, что отрезок Pi проходит через точку 0 !!!!!!!!!!
                crossingNode.SupportFuncValue = alpha * currentCrossingObject.PositiveNode.SupportFuncValue +
                                                beta * currentCrossingObject.NegativeNode.SupportFuncValue;
                return crossingNode;
            }
            Debug.Assert(approxComparer.EQ(Vector3D.ScalarProduct(currentCrossingObject.PositiveNode.NodeNormal, directionPi), 0));
            return currentCrossingObject.PositiveNode;
        }

        private static void AddCrossingNodeBetweenConn(CrossingObject crossingObject, Polyhedron3DGraphNode crossingNode)
        {
            Debug.Assert(crossingObject.CrossingObjectType == CrossingObjectType.GraphConnection);
            // добавл€ем в список ссылок нового узла ссылки сначала на положительный узел св€зи, потом на отрицательный
            Polyhedron3DGraphNode plusNode = crossingObject.PositiveNode;
            Polyhedron3DGraphNode minusNode = crossingObject.NegativeNode;
            crossingNode.ConnectionList.Add(plusNode);
            crossingNode.ConnectionList.Add(minusNode);
            // дл€ узлов, образующих св€зь, мен€ем их ссылки друг на друга (которые и образуют св€зь) на ссылку на новый узел
            plusNode.ConnectionList[plusNode.ConnectionList.IndexOf(minusNode)] = crossingNode;
            minusNode.ConnectionList[minusNode.ConnectionList.IndexOf(plusNode)] = crossingNode;
        }

        private static void AddConnectionsIfNeed(CrossingObject previousCrossingObject,
                                                 Polyhedron3DGraphNode previousCrossingNode,
                                                 CrossingObject currentCrossingObject,
                                                 Polyhedron3DGraphNode currentCrossingNode)
        {
            if(previousCrossingObject.CrossingObjectType == CrossingObjectType.GraphNode &&
               currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection)
                AddConnections4PrevNodeCurrentConn(previousCrossingObject, currentCrossingObject, currentCrossingNode);
            if(previousCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection &&
               currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphNode)
                AddConnections4PrevConnCurrentNode(previousCrossingObject, previousCrossingNode, currentCrossingObject);
            if(previousCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection &&
               currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection)
                AddConnections4PrevConnCurrentConn(previousCrossingObject, previousCrossingNode, currentCrossingObject, currentCrossingNode);
        }

        private static void AddConnections4PrevNodeCurrentConn(CrossingObject previousCrossingObject,
                                                               CrossingObject currentCrossingObject,
                                                               Polyhedron3DGraphNode currentCrossingNode)
        {
            Debug.Assert(previousCrossingObject.CrossingObjectType == CrossingObjectType.GraphNode);
            Debug.Assert(currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection);

            Polyhedron3DGraphNode positiveNode = currentCrossingObject.PositiveNode;
            Polyhedron3DGraphNode negativeNode = currentCrossingObject.NegativeNode;
            Polyhedron3DGraphNode thirdTrNode = positiveNode.ConnectionList.GetPrevItem(currentCrossingNode);
            // инвариант целостности графа
            Debug.Assert(thirdTrNode == negativeNode.ConnectionList.GetNextItem(currentCrossingNode));
            thirdTrNode.ConnectionList.Insert(thirdTrNode.ConnectionList.IndexOf(positiveNode), currentCrossingNode);
            currentCrossingNode.ConnectionList.Insert(currentCrossingNode.ConnectionList.IndexOf(negativeNode),
                                                      thirdTrNode);
        }

        private static void AddConnections4PrevConnCurrentNode(CrossingObject previousCrossingObject,
                                                               Polyhedron3DGraphNode previousCrossingNode,
                                                               CrossingObject currentCrossingObject)
        {
            Debug.Assert(previousCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection);
            Debug.Assert(currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphNode);

            Polyhedron3DGraphNode positiveNode = previousCrossingObject.PositiveNode;
            Polyhedron3DGraphNode negativeNode = previousCrossingObject.NegativeNode;
            Polyhedron3DGraphNode thirdTrNode = positiveNode.ConnectionList.GetNextItem(previousCrossingNode);
            // инвариант целостности графа
            Debug.Assert(thirdTrNode == negativeNode.ConnectionList.GetPrevItem(previousCrossingNode));
            thirdTrNode.ConnectionList.Insert(thirdTrNode.ConnectionList.IndexOf(negativeNode), previousCrossingNode);
            previousCrossingNode.ConnectionList.Insert(previousCrossingNode.ConnectionList.IndexOf(positiveNode),
                                                       thirdTrNode);
        }

        // TODO : реFUCKторинг
        private static void AddConnections4PrevConnCurrentConn(CrossingObject previousCrossingObject,
                                                               Polyhedron3DGraphNode previousCrossingNode,
                                                               CrossingObject currentCrossingObject,
                                                               Polyhedron3DGraphNode currentCrossingNode)
        {
            Debug.Assert(previousCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection);
            Debug.Assert(currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection);

            // у св€зей общий отрицательный узел (случай 3а)
            if(ReferenceEquals(previousCrossingObject.NegativeNode, currentCrossingObject.NegativeNode))
            {
                // положительный узел предыдущей св€зи (узел номер 1)
                Polyhedron3DGraphNode node1 = previousCrossingObject.PositiveNode;
                // общий отрицательный узел (узел номер 2)
                Polyhedron3DGraphNode node2 = previousCrossingObject.NegativeNode;
                // положительный узел текущей св€зи (узел номер 3)
                Polyhedron3DGraphNode node3 = currentCrossingObject.PositiveNode;
                // дл€ узла номер 3: ссылка на предыдущей узел пересечени€ вставл€етс€ после ссылки на узел 1
                node3.ConnectionList.Insert(node3.ConnectionList.IndexOf(node1) + 1,
                                            previousCrossingNode);
                // дл€ предыдущего узла пересечени€: после узла 2 добавл€етс€ сначала ссылка на новый узел пересечени€, потом ссылка на узел номер 3
                previousCrossingNode.ConnectionList.Insert(previousCrossingNode.ConnectionList.IndexOf(node2) + 1,
                                                           currentCrossingNode);
                previousCrossingNode.ConnectionList.Insert(previousCrossingNode.ConnectionList.IndexOf(node2) + 2,
                                                           node3);
                // дл€ текущего узла пересечени€: ссылка на предыдущий узел пересечени€ вставл€етс€ после ссылки на узел номер 3
                currentCrossingNode.ConnectionList.Insert(currentCrossingNode.ConnectionList.IndexOf(node3) + 1,
                                                          previousCrossingNode);
            }
                // у св€зай общий положительный узел (случай 3б)
            else if(ReferenceEquals(previousCrossingObject.PositiveNode, currentCrossingObject.PositiveNode))
            {
                // отрицательный узел предыдущей св€зи (узел номер 1)
                Polyhedron3DGraphNode node1 = previousCrossingObject.NegativeNode;
                // общий положительный узел (узел номер 2)
                Polyhedron3DGraphNode node2 = previousCrossingObject.PositiveNode;
                // отрицательный узел текущей св€зи (узел номер 3)
                Polyhedron3DGraphNode node3 = currentCrossingObject.NegativeNode;
                // дл€ узла номер 3: ссылка на предыдущей узел пересечени€ вставл€етс€ после ссылки на текущий узел пересечени€
                node3.ConnectionList.Insert(node3.ConnectionList.IndexOf(currentCrossingNode) + 1,
                                            previousCrossingNode);
                // дл€ предыдущего узла пересечени€: посде узла 1 добавл€етс€ сначала ссылка на узел номер 3, потом ссылка на новый узел пересечени€
                previousCrossingNode.ConnectionList.Insert(previousCrossingNode.ConnectionList.IndexOf(node1) + 1,
                                                           node3);
                previousCrossingNode.ConnectionList.Insert(previousCrossingNode.ConnectionList.IndexOf(node1) + 2,
                                                           currentCrossingNode);
                // дл€ текущего узла пересечени€: ссылка на предыдущий узел пересечени€ вставл€етс€ после ссылки на узел номер 2
                currentCrossingNode.ConnectionList.Insert(currentCrossingNode.ConnectionList.IndexOf(node2) + 1,
                                                          previousCrossingNode);
            }
            else
                throw new Exception("Abnormal algorithm result");
        }

        private readonly ApproxComp approxComparer;
        private readonly ApproxComp angleNearnessComparer;
        private readonly Double deltaT;
        private readonly Matrix matrixB;
        private readonly Double mpMax;
        private readonly Double mpMin;

        ///// <summary>
        ///// метод BuildGFiGrid строит сетку G(...Fi...) (см. алгоритм)
        ///// </summary>
        ///// <param name="graph">граф, который достраиваетс€ до сетки G(...Fi...)</param>
        ///// <param name="directingVectorPi">направл€ющий вектор отрезка Pi</param>
        ///// <param name="generationID">ID поколени€</param>
        ///// <returns>сетка G(...Fi...)</returns>
        //private Polyhedron3DGraph BuildGFiGrid(Polyhedron3DGraph graph, Vector3D directingVectorPi, Int32 generationID)
        //{
        //    // объект дл€ поиска пересечений графа с G(...Pi...)
        //    CrossingObjectFinder finder = new CrossingObjectFinder(m_ApproxComparer);

        //    // первый (запомненный) объект пересечени€
        //    CrossingObject firstCrossingObject = finder.GetFirstCrossingObject(graph.NodeList[0], directingVectorPi);
        //    // текущий объект пересечени€
        //    CrossingObject currentCrossingObject = firstCrossingObject;
        //    // строим узел на пересечении текущего объекта и G(...Pi...) и запоминаем его
        //    // если этот узел отсутствует в списке узлов, то добавл€ем его и соответствующие ссылки на данный узел
        //    Polyhedron3DGraphNode firstCrossingNode = BuildCrossingNode(currentCrossingObject, graph, directingVectorPi, generationID);
        //    // текущий узел пересечени€
        //    Polyhedron3DGraphNode currentCrossingNode = firstCrossingNode;

        //    if (currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection)
        //    {
        //        graph.NodeList.Add(currentCrossingNode);
        //        AddCrossingNodeBetweenConn(currentCrossingObject.PositiveNode, currentCrossingObject.NegativeNode, currentCrossingNode);
        //    }

        //    // ÷икл (пока текущий объект не станет равным запомненному)
        //    do
        //    {
        //        // предыдущий объект пересечени€
        //        CrossingObject previousCrossingObject = currentCrossingObject;
        //        // предыдущий узел пересечени€
        //        Polyhedron3DGraphNode previousCrossingNode = currentCrossingNode;
        //        // получаем следующий по движению объект (св€зь, либо узел) и делаем его текущим
        //        currentCrossingObject = finder.GetNextCrossingObject(currentCrossingObject, currentCrossingNode, directingVectorPi);
        //        // строим узел на пересечении текущего объекта и G(...Pi...)
        //        // если этот узел отсутствует в списке узлов (этот узел будет присутствовать в списке узлов, если текущий объект Ц узел, либо если начальным объектом была св€зь и мы в нее пришли), то добавл€ем его и соответствующие ссылки на данный узел
        //        // отдельно обрабатываем случай если мы пришли в первый (запомненный) объект пересечени€ (дл€ простоты реализации алгоритма)
        //        currentCrossingNode = (currentCrossingObject == firstCrossingObject ?
        //                               firstCrossingNode :
        //                               BuildCrossingNode(currentCrossingObject, graph, directingVectorPi, generationID));
        //        if (currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection &&
        //            currentCrossingObject != firstCrossingObject)
        //        {
        //            graph.NodeList.Add(currentCrossingNode);
        //            AddCrossingNodeBetweenConn(currentCrossingObject.PositiveNode, currentCrossingObject.NegativeNode, currentCrossingNode);
        //        }

        //        // если предыдущий и текущий объекты Ц узлы
        //        if (previousCrossingObject.CrossingObjectType == CrossingObjectType.GraphNode &&
        //            currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphNode)
        //        {
        //            // переход к следующей итерации цикла
        //            // continue;
        //        }

        //        // если предыдущий объект узел, а текущий св€зь
        //        if (previousCrossingObject.CrossingObjectType == CrossingObjectType.GraphNode &&
        //            currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection)
        //        {
        //            // —троим св€зи между предыдущим узлом и узлом пересечени€ на текущем объекте
        //            AddConns4PrevNodeCurrentConnCase(previousCrossingObject, previousCrossingNode, currentCrossingObject, currentCrossingNode);
        //        }

        //        // если предыдущий объект св€зь, а текущий узел
        //        if (previousCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection &&
        //            currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphNode)
        //        {
        //            // —троим св€зи между узлом пересечени€ на предыдущем объекте и текущем узле
        //            AddConns4PrevConnCurrentNodeCase(previousCrossingObject, previousCrossingNode, currentCrossingObject, currentCrossingNode);
        //        }

        //        // если предыдущий и текущий объекты - св€зи
        //        if (previousCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection &&
        //            currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection)
        //        {
        //            // —троим св€зи между узлом пересечени€ на предыдущем объекте и узлом пересечени€ на текущем объекте
        //            // —троим св€зь между узлом пересечени€ на предыдущем объекте и узлом текущей св€зи, который не принадлежит предыдущей св€зи
        //            AddConns4PrevConnCurrentConnCase(previousCrossingObject, previousCrossingNode, currentCrossingObject, currentCrossingNode);
        //        }
        //    }
        //    while (currentCrossingObject != firstCrossingObject);
        //    // ÷икл (пока текущий объект не станет равным запомненному)

        //    return graph;
        //}

//        /// <summary>
//        /// метод BuildGFiGrid строит сетку G(...Fi...) (см. алгоритм)
//        /// </summary>
//        /// <param name="graph">граф, который достраиваетс€ до сетки G(...Fi...)</param>
//        /// <param name="directingVectorPi">направл€ющий вектор отрезка Pi</param>
//        /// <param name="generationID">ID поколени€</param>
//        /// <returns>сетка G(...Fi...)</returns>
//        private Polyhedron3DGraph BuildGFiGrid(Polyhedron3DGraph graph, Vector3D directingVectorPi, Int32 generationID)
//        {
//            const Double epsilon = 0.02;
//            ApproxComp cosAngleComparer = new ApproxComp(epsilon*epsilon);

//            // объект дл€ поиска пересечений графа с G(...Pi...)
//            CrossingObjectsSearch finder = new CrossingObjectsSearch(m_ApproxComparer);

//            // первый (запомненный) объект пересечени€
//            CrossingObject firstCrObject = finder.GetFirstCrossingObject(graph.NodeList[0], directingVectorPi);
//            // строим узел на пересечении текущего объекта и G(...Pi...) и запоминаем его
//            // если этот узел отсутствует в списке узлов, то добавл€ем его и соответствующие ссылки на данный узел
//            Polyhedron3DGraphNode firstCrNode = BuildCrossingNode(firstCrObject, graph, directingVectorPi, generationID);

//            // текущий объект пересечени€
//            CrossingObject currentCrObject = firstCrObject;
//            // текущий узел пересечени€
//            Polyhedron3DGraphNode currentCrNode = firstCrNode;

//            // узел пересечени€, который будет построен
//            Polyhedron3DGraphNode actualCrNode = firstCrNode;
//            // объект пересечени€, который будет построен
//            CrossingObject actualCrObject = CheckNodesNearnessAndCorrect(firstCrObject, ref actualCrNode, cosAngleComparer);

//            //if (currentCrObject.CrossingObjectType == CrossingObjectType.GraphConnection)
//            //{
//            //    graph.NodeList.Add(currentCrNode);
//            //    AddCrossingNodeBetweenConn(currentCrObject.PositiveNode, currentCrObject.NegativeNode, currentCrNode);
//            //}
//            if (actualCrObject.CrossingObjectType == CrossingObjectType.GraphConnection)
//            {
//                graph.NodeList.Add(actualCrNode);
//                AddCrossingNodeBetweenConn(actualCrObject.PositiveNode, actualCrObject.NegativeNode, actualCrNode);
//            }

//            //
//            Boolean reachFirstCrObject;
//            // ÷икл (пока текущий объект не станет равным запомненному)
//            do
//            {
//                // получаем следующий по движению объект (св€зь, либо узел) и делаем его текущим
//                if (graph.NodeList[graph.NodeList.Count - 1] == currentCrNode)
//                {
//                    currentCrObject = finder.GetNextCrossingObject(currentCrObject, currentCrNode, directingVectorPi);
//                }
//                else
//                {
//                    currentCrObject = finder.GetNextCrossingObject(currentCrObject, directingVectorPi);
//                }
//                // строим узел на пересечении текущего объекта и G(...Pi...)
//                // если этот узел отсутствует в списке узлов (этот узел будет присутствовать в списке узлов, если текущий объект Ц узел, либо если начальным объектом была св€зь и мы в нее пришли),
//                // то добавл€ем его и соответствующие ссылки на данный узел
//                // отдельно обрабатываем случай если мы пришли в первый (запомненный) объект пересечени€ (дл€ простоты реализации алгоритма)
//                currentCrNode = (currentCrObject == firstCrObject
//                                     ? firstCrNode
//                                     : BuildCrossingNode(currentCrObject, graph, directingVectorPi, generationID));
//                //
//                reachFirstCrObject = (currentCrObject == firstCrObject);
//                // предыдущий объект пересечени€
//                CrossingObject prevActualCrObject = actualCrObject;
//                // предыдущий узел пересечени€
//                Polyhedron3DGraphNode prevActualCrNode = actualCrNode;
//                // узел пересечени€, который будет построен
//                actualCrNode = currentCrNode;
//                // объект пересечени€, который будет построен
//                actualCrObject = CheckNodesNearnessAndCorrect(currentCrObject, ref actualCrNode, cosAngleComparer);
//                //
//                if (actualCrObject.CrossingObjectType == CrossingObjectType.GraphConnection && !reachFirstCrObject)
//                {
//                    graph.NodeList.Add(actualCrNode);
//                    AddCrossingNodeBetweenConn(actualCrObject.PositiveNode, actualCrObject.NegativeNode, actualCrNode);
//                }

//                // если предыдущий и текущий объекты Ц узлы
//                if (prevActualCrObject.CrossingObjectType == CrossingObjectType.GraphNode &&
//                    actualCrObject.CrossingObjectType == CrossingObjectType.GraphNode)
//                {
//                    // переход к следующей итерации цикла
//                    // continue;
//                }

//                // если предыдущий объект узел, а текущий св€зь
//                if (prevActualCrObject.CrossingObjectType == CrossingObjectType.GraphNode &&
//                    actualCrObject.CrossingObjectType == CrossingObjectType.GraphConnection)
//                {
//                    // —троим св€зи между предыдущим узлом и узлом пересечени€ на текущем объекте
//                    AddConns4PrevNodeCurrentConnCase(prevActualCrObject, prevActualCrNode, actualCrObject, actualCrNode);
//                }

//                // если предыдущий объект св€зь, а текущий узел
//                if (prevActualCrObject.CrossingObjectType == CrossingObjectType.GraphConnection &&
//                    actualCrObject.CrossingObjectType == CrossingObjectType.GraphNode)
//                {
//                    // —троим св€зи между узлом пересечени€ на предыдущем объекте и текущем узле
//                    AddConns4PrevConnCurrentNodeCase(prevActualCrObject, prevActualCrNode, actualCrObject, actualCrNode);
//                }

//                // если предыдущий и текущий объекты - св€зи
//                if (prevActualCrObject.CrossingObjectType == CrossingObjectType.GraphConnection &&
//                    actualCrObject.CrossingObjectType == CrossingObjectType.GraphConnection)
//                {
//                    // —троим св€зи между узлом пересечени€ на предыдущем объекте и узлом пересечени€ на текущем объекте
//                    // —троим св€зь между узлом пересечени€ на предыдущем объекте и узлом текущей св€зи, который не принадлежит предыдущей св€зи
//                    AddConns4PrevConnCurrentConnCase(prevActualCrObject, prevActualCrNode, actualCrObject, actualCrNode);
//                }
//            } while (!reachFirstCrObject);
//            // ÷икл (пока текущий объект не станет равным запомненному)

//            return graph;
//        }

//        private CrossingObject CheckNodesNearnessAndCorrect(CrossingObject crossingObject,
//                                                            ref Polyhedron3DGraphNode crossingNode,
//                                                            ApproxComp cosAngleComparer)
//        {
//            if (crossingObject.CrossingObjectType == CrossingObjectType.GraphNode)
//            {
//                return crossingObject;
//            }

//            Double positiveNodeCosAngle = Vector3DUtils.CosAngleBetweenVectors(crossingNode.NodeNormal,
//                                                                               crossingObject.PositiveNode.NodeNormal);
//            Double negativeNodeCosAngle = Vector3DUtils.CosAngleBetweenVectors(crossingNode.NodeNormal,
//                                                                               crossingObject.NegativeNode.NodeNormal);

//            if (positiveNodeCosAngle >= negativeNodeCosAngle && cosAngleComparer.EQ(positiveNodeCosAngle, 1))
//            {
//                crossingNode = crossingObject.PositiveNode;
//                return new CrossingObject(CrossingObjectType.GraphNode, crossingNode, crossingNode);
//            }

//            if (negativeNodeCosAngle >= positiveNodeCosAngle && cosAngleComparer.EQ(negativeNodeCosAngle, 1))
//            {
//                crossingNode = crossingObject.NegativeNode;
//                return new CrossingObject(CrossingObjectType.GraphNode, crossingNode, crossingNode);
//            }

//            return crossingObject;
//        }

//        /// <summary>
//        /// метод CalcCrossingNodeNormal вычисл€ет нормаль узла на текущем пересечении графа с G(...Pi...)
//        /// </summary>
//        /// <param name="currentCrossingObject">текущий объект пересечени€ графа с G(...Pi...)</param>
//        /// <param name="directingVectorPi">направл€ющий вектор отрезка Pi</param>
//        /// <returns>нормаль узла на текущем пересечении графа с G(...Pi...)</returns>
//        private Vector3D CalcCrossingNodeNormal(CrossingObject currentCrossingObject, Vector3D directingVectorPi)
//        {
//            Vector3D crossingNodeNormal;

//            if (currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection)
//            {
//                Vector3D plusVector = currentCrossingObject.PositiveNode.NodeNormal;
//                Vector3D minusVector = currentCrossingObject.NegativeNode.NodeNormal;
//                // —троим вектор, перпендикул€рный векторам, св€занным текущей св€зью,
//                // как векторное произведение положительного узла св€зи на отрицательный
//                Vector3D npm = Vector3D.VectorProduct(plusVector, minusVector);
//                // ¬ычисл€ем векторное произведение построенного вектора и направл€ющего вектора Pi
//                crossingNodeNormal = Vector3D.VectorProduct(npm, directingVectorPi);
//                crossingNodeNormal.Normalize();
//            }
//            else
//            {
//                crossingNodeNormal = currentCrossingObject.PositiveNode.NodeNormal;
//            }

//            return crossingNodeNormal;
//        }

//        /// <summary>
//        /// метод BuildCrossingNode создает и возвращает узел на текущем пересечении графа с G(...Pi...)
//        /// </summary>
//        /// <param name="currentCrossingObject">текущий объект пересечени€ графа с G(...Pi...)</param>
//        /// <param name="graph">граф</param>
//        /// <param name="directingVectorPi">направл€ющий вектор отрезка Pi</param>
//        /// <param name="generationID">ID поколени€</param>
//        /// <returns>созданный узел на текущем пересечении графа с G(...Pi...)</returns>
//        private Polyhedron3DGraphNode BuildCrossingNode(CrossingObject currentCrossingObject, Polyhedron3DGraph graph,
//                                                        Vector3D directingVectorPi, Int32 generationID)
//        {
//            Polyhedron3DGraphNode crossingNode;

//            if (currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection)
//            {
//                Vector3D plusNodeNormal = currentCrossingObject.PositiveNode.NodeNormal;
//                Vector3D minusNodeNormal = currentCrossingObject.NegativeNode.NodeNormal;
//                Vector3D crossingNodeNormal = CalcCrossingNodeNormal(currentCrossingObject, directingVectorPi);

//                // —троим узел, св€занный с полученным (выше) вектором и возвращаем его
//                crossingNode = new Polyhedron3DGraphNode(graph.NodeList.Count, generationID, crossingNodeNormal);
//                // подсчет значени€ опорной функции дл€ построенного узла
//                // (l1, l):
//                Double scalarProduct1 = plusNodeNormal*crossingNodeNormal;
//                // (l2, l):
//                Double scalarProduct2 = minusNodeNormal*crossingNodeNormal;
//                // (l1, l2):
//                Double scalarProduct12 = plusNodeNormal*minusNodeNormal;
//                // delta = 1 - (l1, l2)*(l1, l2)
//                Double delta = 1 - scalarProduct12*scalarProduct12;

//                Double alpha = (scalarProduct1 - scalarProduct12*scalarProduct2)/delta;
//                Double beta = (scalarProduct2 - scalarProduct12*scalarProduct1)/delta;

//#warning ќ„≈Ќ№ ¬ј∆Ќќ !!!!!! ѕ–ќ¬≈–»“№ ѕ–ј¬»Ћ№Ќќ—“№ ѕќЋ”„≈Ќ»я «Ќј„≈Ќ»я ќѕќ–Ќќ… ‘”Ќ ÷»»
//#warning ќ„≈Ќ№ ¬ј∆Ќќ !!!!!! считаем, что отрезок Pi проходит через точку 0 !!!!!!!!!!
//                crossingNode.SupportFuncValue = alpha*currentCrossingObject.PositiveNode.SupportFuncValue +
//                                                beta*currentCrossingObject.NegativeNode.SupportFuncValue;
//            }
//            else
//            {
//                // ¬ычисл€ем скал€рное произведение вектора, св€занного с текущим узлом, и направл€ющего вектора Pi
//                // ≈сли скал€рное произведение <> 0, то это ошибка работы алгоритма
//#warning Check is absent !!!

//                crossingNode = currentCrossingObject.PositiveNode;
//            }

//            return crossingNode;
//        }

//        /// <summary>
//        /// метод AddCrossingNodeBetweenConn добавл€ет узел crossingNode на пересечении св€зи и G(...Pi...) и соответствующим образом правит/добавл€ет ссылки
//        /// </summary>
//        /// <param name="connPlusNode">положительный узел пересекаемой св€зи</param>
//        /// <param name="connMinusNode">отрицательный узел пересекаемой св€зи</param>
//        /// <param name="crossingNode">узел на пересечении св€зи и G(...Pi...)</param>
//        private void AddCrossingNodeBetweenConn(Polyhedron3DGraphNode connPlusNode, Polyhedron3DGraphNode connMinusNode,
//                                                Polyhedron3DGraphNode crossingNode)
//        {
//            // возложение на метод левых функций
//            /*// добавл€ем новый узел в список узлов графа
//            graph.NodeList.Add(crossingNode);*/
//            // возложение на метод левых функций

//            // добавл€ем в список ссылок нового узла ссылки сначала на положительный узел св€зи, потом на отрицательный
//            crossingNode.ConnectionList.Add(connPlusNode);
//            crossingNode.ConnectionList.Add(connMinusNode);
//            // дл€ узлов, образующих св€зь, мен€ем их ссылки друг на друга (которые и образуют св€зь) на ссылку на новый узел
//            connPlusNode.ConnectionList[connPlusNode.ConnectionList.IndexOf(connMinusNode)] = crossingNode;
//            connMinusNode.ConnectionList[connMinusNode.ConnectionList.IndexOf(connPlusNode)] = crossingNode;
//        }

//        /// <summary>
//        /// метод AddConns4PrevNodeCurrentConnCase добавл€ет необходимые св€зи в случае, если предыдущий объект пересечени€ - узел, а текущий - св€зь
//        /// св€зи добавл€ютс€ дл€ того, чтобы граф оставалс€ триангулированным
//        /// </summary>
//        /// <param name="previousCrossingObject">предыдущий объект пересечени€ графа с G(...Pi...)</param>
//        /// <param name="previousCrossingNode">узел на предыдущем пересечении графа с G(...Pi...)</param>
//        /// <param name="currentCrossingObject">текущий объект пересечени€ графа с G(...Pi...)</param>
//        /// <param name="currentCrossingNode">узел на текущем пересечении графа с G(...Pi...)</param>
//        private void AddConns4PrevNodeCurrentConnCase(CrossingObject previousCrossingObject,
//                                                      Polyhedron3DGraphNode previousCrossingNode,
//                                                      CrossingObject currentCrossingObject,
//                                                      Polyhedron3DGraphNode currentCrossingNode)
//        {
//            Debug.Assert(previousCrossingObject.CrossingObjectType == CrossingObjectType.GraphNode &&
//                         currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection,
//                         "previous crossing object must be node and current crossing object - connection");

//            //// строим св€зи между предыдущим узлом и узлом пересечени€ на текущем объекте :

//            //// отрицательный узел текущей св€зи
//            //Polyhedron3DGraphNode connMinusNode = currentCrossingObject.NegativeNode;
//            //// ссылку на текущий узел пересечени€ в список ссылок предыдущего узла вставл€ем после ссылки на отрицательный узел текущей св€зи
//            ///*Int32 PrevNode2CurrentMinusNodeConnIndex = PreviousCrossingNode.GetConnectionIndex(CurrentConnMinusNode);
//            //PreviousCrossingNode.InsertNodeConnection(PrevNode2CurrentMinusNodeConnIndex + 1, CurrentCrossingNode);*/
//            //previousCrossingNode.ConnectionList.Insert(previousCrossingNode.ConnectionList.IndexOf(connMinusNode) + 1,
//            //                                           currentCrossingNode);
//            //// ссылку на предыдущий узел вставл€ем после ссылки на положительный узел текущей св€зи (на позицию номер 1)
//            //currentCrossingNode.ConnectionList.Insert(1, previousCrossingNode);

//            Polyhedron3DGraphNode positiveNode = currentCrossingObject.PositiveNode;
//            Polyhedron3DGraphNode negativeNode = currentCrossingObject.NegativeNode;
//            Polyhedron3DGraphNode thirdTrNode = positiveNode.ConnectionList.GetPrevItem(currentCrossingNode);
//            thirdTrNode.ConnectionList.Insert(thirdTrNode.ConnectionList.IndexOf(positiveNode), currentCrossingNode);
//            currentCrossingNode.ConnectionList.Insert(currentCrossingNode.ConnectionList.IndexOf(negativeNode),
//                                                      thirdTrNode);
//        }

//        /// <summary>
//        /// метод AddConns4PrevConnCurrentNodeCase добавл€ет необходимые св€зи в случае, если предыдущий объект пересечени€ - св€зь, а текущий - узел
//        /// св€зи добавл€ютс€ дл€ того, чтобы граф оставалс€ триангулированным
//        /// </summary>
//        /// <param name="previousCrossingObject">предыдущий объект пересечени€ графа с G(...Pi...)</param>
//        /// <param name="previousCrossingNode">узел на предыдущем пересечении графа с G(...Pi...)</param>
//        /// <param name="currentCrossingObject">текущий объект пересечени€ графа с G(...Pi...)</param>
//        /// <param name="currentCrossingNode">узел на текущем пересечении графа с G(...Pi...)</param>
//        private void AddConns4PrevConnCurrentNodeCase(CrossingObject previousCrossingObject,
//                                                      Polyhedron3DGraphNode previousCrossingNode,
//                                                      CrossingObject currentCrossingObject,
//                                                      Polyhedron3DGraphNode currentCrossingNode)
//        {
//            Debug.Assert(previousCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection &&
//                         currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphNode,
//                         "previous crossing object must be connection and current crossing object - node");

//            //// строим св€зи между узлом пересечени€ на предыдущем объекте и текущем узле :

//            //// положительный узел предыдущей св€зи
//            //Polyhedron3DGraphNode connPlusNode = previousCrossingObject.PositiveNode;
//            //// ссылку на предыдущий узел пересечени€ в список ссылок текущего узла вставл€ем после ссылки на положительный узел предыдущей св€зи
//            ///*Int32 CurrentNode2PrevPlusNodeConnIndex = CurrentCrossingNode.GetConnectionIndex(PreviousConnPlusNode);
//            //CurrentCrossingNode.InsertNodeConnection(CurrentNode2PrevPlusNodeConnIndex + 1, PreviousCrossingNode);*/
//            //currentCrossingNode.ConnectionList.Insert(currentCrossingNode.ConnectionList.IndexOf(connPlusNode) + 1,
//            //                                          previousCrossingNode);
//            //// ссылку на текущий узел добавл€ем в конец списка ссылок предыдущего узла
//            //previousCrossingNode.ConnectionList.Add(currentCrossingNode);

//            Polyhedron3DGraphNode positiveNode = previousCrossingObject.PositiveNode;
//            Polyhedron3DGraphNode negativeNode = previousCrossingObject.NegativeNode;
//            Polyhedron3DGraphNode thirdTrNode = positiveNode.ConnectionList.GetNextItem(previousCrossingNode);
//            thirdTrNode.ConnectionList.Insert(thirdTrNode.ConnectionList.IndexOf(negativeNode), previousCrossingNode);
//            previousCrossingNode.ConnectionList.Insert(previousCrossingNode.ConnectionList.IndexOf(positiveNode),
//                                                       thirdTrNode);
//        }

//        /// <summary>
//        /// метод AddConns4PrevConnCurrentConnCase добавл€ет необходимые св€зи в случае, если и предыдущий, и текущий объекты пересечени€ - св€зи
//        /// св€зи добавл€ютс€ дл€ того, чтобы граф оставалс€ триангулированным
//        /// </summary>
//        /// <param name="previousCrossingObject">предыдущий объект пересечени€ графа с G(...Pi...)</param>
//        /// <param name="previousCrossingNode">узел на предыдущем пересечении графа с G(...Pi...)</param>
//        /// <param name="currentCrossingObject">текущий объект пересечени€ графа с G(...Pi...)</param>
//        /// <param name="currentCrossingNode">узел на текущем пересечении графа с G(...Pi...)</param>
//        private void AddConns4PrevConnCurrentConnCase(CrossingObject previousCrossingObject,
//                                                      Polyhedron3DGraphNode previousCrossingNode,
//                                                      CrossingObject currentCrossingObject,
//                                                      Polyhedron3DGraphNode currentCrossingNode)
//        {
//            Debug.Assert(previousCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection &&
//                         currentCrossingObject.CrossingObjectType == CrossingObjectType.GraphConnection,
//                         "previous and current crossing objects must be connections");

//            // строим св€зи между узлом пересечени€ на предыдущем объекте и узлом пересечени€ на текущем объекте
//            // строим св€зь между узлом пересечени€ на предыдущем объекте и узлом текущей св€зи, который не принадлежит предыдущей св€зи
//            // у св€зай общий отрицательный узел (случай 3а)
//            if (ReferenceEquals(previousCrossingObject.NegativeNode, currentCrossingObject.NegativeNode))
//            {
//                //// положительный узел предыдущей св€зи (узел номер 1)
//                //Polyhedron3DGraphNode node1 = previousCrossingObject.PositiveNode;
//                //// общий отрицательный узел (узел номер 2)
//                //// Polyhedron3DGraphNode node2 = previousCrossingObject.NegativeNode;
//                //// положительный узел текущей св€зи (узел номер 3)
//                //Polyhedron3DGraphNode node3 = currentCrossingObject.PositiveNode;
//                //// дл€ узла номер 3: ссылка на предыдущей узел пересечени€ вставл€етс€ после ссылки на узел 1                
//                //node3.ConnectionList.Insert(node3.ConnectionList.IndexOf(node1) + 1, previousCrossingNode);
//                //// дл€ предыдущего узла пересечени€: в конец списка ссылок добавл€етс€ сначала ссылка на новый узел пересечени€, потом ссылка на узел номер 3
//                //previousCrossingNode.ConnectionList.Add(currentCrossingNode);
//                //previousCrossingNode.ConnectionList.Add(node3);
//                //// дл€ текущего узла пересечени€: ссылка на предыдущий узел пересечени€ вставл€етс€ после ссылки на узел номер 3 (т.е. на позицию номер 1)
//                //currentCrossingNode.ConnectionList.Insert(1, previousCrossingNode);
//                // положительный узел предыдущей св€зи (узел номер 1)
//                Polyhedron3DGraphNode node1 = previousCrossingObject.PositiveNode;
//                // общий отрицательный узел (узел номер 2)
//                Polyhedron3DGraphNode node2 = previousCrossingObject.NegativeNode;
//                // положительный узел текущей св€зи (узел номер 3)
//                Polyhedron3DGraphNode node3 = currentCrossingObject.PositiveNode;
//                // дл€ узла номер 3: ссылка на предыдущей узел пересечени€ вставл€етс€ после ссылки на узел 1                
//                node3.ConnectionList.Insert(node3.ConnectionList.IndexOf(node1) + 1, previousCrossingNode);
//                // дл€ предыдущего узла пересечени€: после узла 2 добавл€етс€ сначала ссылка на новый узел пересечени€, потом ссылка на узел номер 3
//                previousCrossingNode.ConnectionList.Insert(previousCrossingNode.ConnectionList.IndexOf(node2) + 1,
//                                                           currentCrossingNode);
//                previousCrossingNode.ConnectionList.Insert(previousCrossingNode.ConnectionList.IndexOf(node2) + 2, node3);
//                // дл€ текущего узла пересечени€: ссылка на предыдущий узел пересечени€ вставл€етс€ после ссылки на узел номер 3
//                currentCrossingNode.ConnectionList.Insert(currentCrossingNode.ConnectionList.IndexOf(node3) + 1,
//                                                          previousCrossingNode);
//            }
//                // у св€зай общий положительный узел (случай 3б)
//            else if (ReferenceEquals(previousCrossingObject.PositiveNode, currentCrossingObject.PositiveNode))
//            {
//                //// отрицательный узел предыдущей св€зи (узел номер 1)
//                ////Polyhedron3DGraphNode node1 = previousCrossingObject.NegativeNode;
//                //// общий положительный узел (узел номер 2)
//                //// Polyhedron3DGraphNode node2 = previousCrossingObject.PositiveNode;
//                //// отрицательный узел текущей св€зи (узел номер 3)
//                //Polyhedron3DGraphNode node3 = currentCrossingObject.NegativeNode;
//                //// дл€ узла номер 3: ссылка на предыдущей узел пересечени€ вставл€етс€ после ссылки на текущий узел пересечени€
//                //node3.ConnectionList.Insert(node3.ConnectionList.IndexOf(currentCrossingNode) + 1, previousCrossingNode);
//                //// дл€ предыдущего узла пересечени€: в конец списка ссылок добавл€етс€ сначала ссылка на узел номер 3, потом ссылка на новый узел пересечени€
//                //previousCrossingNode.ConnectionList.Add(node3);
//                //previousCrossingNode.ConnectionList.Add(currentCrossingNode);
//                //// дл€ текущего узла пересечени€: ссылка на предыдущий узел пересечени€ вставл€етс€ после ссылки на узел номер 1 (т.е. на позицию номер 1)
//                //currentCrossingNode.ConnectionList.Insert(1, previousCrossingNode);
//                // отрицательный узел предыдущей св€зи (узел номер 1)
//                Polyhedron3DGraphNode node1 = previousCrossingObject.NegativeNode;
//                // общий положительный узел (узел номер 2)
//                Polyhedron3DGraphNode node2 = previousCrossingObject.PositiveNode;
//                // отрицательный узел текущей св€зи (узел номер 3)
//                Polyhedron3DGraphNode node3 = currentCrossingObject.NegativeNode;
//                // дл€ узла номер 3: ссылка на предыдущей узел пересечени€ вставл€етс€ после ссылки на текущий узел пересечени€
//                node3.ConnectionList.Insert(node3.ConnectionList.IndexOf(currentCrossingNode) + 1, previousCrossingNode);
//                // дл€ предыдущего узла пересечени€: посде узла 1 добавл€етс€ сначала ссылка на узел номер 3, потом ссылка на новый узел пересечени€
//                previousCrossingNode.ConnectionList.Insert(previousCrossingNode.ConnectionList.IndexOf(node1) + 1, node3);
//                previousCrossingNode.ConnectionList.Insert(previousCrossingNode.ConnectionList.IndexOf(node1) + 2,
//                                                           currentCrossingNode);
//                // дл€ текущего узла пересечени€: ссылка на предыдущий узел пересечени€ вставл€етс€ после ссылки на узел номер 2
//                currentCrossingNode.ConnectionList.Insert(currentCrossingNode.ConnectionList.IndexOf(node2) + 1,
//                                                          previousCrossingNode);
//            }
//                // ошибка работы алгоритма
//            else
//            {
//#warning может более специализированное исключение
//                throw new Exception("AddConns4PrevConnCurrentConnCase method incorrect work");
//            }
//        }
    }
}